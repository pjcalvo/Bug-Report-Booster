var imageURL, os, browser, webURL, environment;


function show(id) { 
   $(id).css({"display":"block"});
}

function hide(id) { 
    $(id).css({"display":"none"});
}

//
// URL Matching test - to verify we can talk to this URL
//

var environments = config.testing_environments;
var matches = [];

for(var i = 0; i < environments.length; i++){
    matches.push(environments[i].url_format);
}
console.log(matches);



function testURLMatches(url) {
    // couldn't find a better way to tell if executeScript
    // wouldn't work -- so just testing against known urls
    // for now...
    var r, i;
    for (i=matches.length-1; i>=0; i--) {
        r = new RegExp('^' + matches[i].replace(/\*/g, '.*') + '$');
        if (r.test(url)) {
                
            environment = config.testing_environments[i].value;
            hide('#verifying');
            show('#loading');
            return true;
        }
    }
    
    show('#verifying');
    return false;
}

//
// Events
//
var screenshot, contentURL = '';

function sendScrollMessage(tab) {
    contentURL = tab.url;
    screenshot = {};
    chrome.tabs.sendRequest(tab.id, {msg: 'scrollPage'}, function() {
        // We're done taking snapshots of all parts of the window. Display
        // the resulting full screenshot image in a new browser tab.
        openPage();
    });
}

function sendLogMessage(data) {
    chrome.tabs.getSelected(null, function(tab) {
        chrome.tabs.sendRequest(tab.id, {msg: 'logMessage', data: data}, function() {});
    });
}

chrome.extension.onRequest.addListener(function(request, sender, callback) {
    if (request.msg === 'capturePage') {
        capturePage(request, sender, callback);
    } else {
        console.error('Unknown message received from content script: ' + request.msg);
    }
});

function capturePage(data, sender, callback) {
    var canvas;

        // Get window.devicePixelRatio from the page, not the popup
    var scale = data.devicePixelRatio && data.devicePixelRatio !== 1 ?
        1 / data.devicePixelRatio : 1;

    // if the canvas is scaled, then x- and y-positions have to make
    // up for it
    if (scale !== 1) {
        data.x = data.x / scale;
        data.y = data.y / scale;
        data.totalWidth = data.totalWidth / scale;
        data.totalHeight = data.totalHeight / scale;
    }


    if (!screenshot.canvas) {
        canvas = document.createElement('canvas');
        canvas.width = data.totalWidth;
        canvas.height = data.totalHeight;
        screenshot.canvas = canvas;
        screenshot.ctx = canvas.getContext('2d');

        // sendLogMessage('TOTALDIMENSIONS: ' + data.totalWidth + ', ' + data.totalHeight);

        // // Scale to account for device pixel ratios greater than one. (On a
        // // MacBook Pro with Retina display, window.devicePixelRatio = 2.)
        // if (scale !== 1) {
        //     // TODO - create option to not scale? It's not clear if it's
        //     // better to scale down the image or to just draw it twice
        //     // as large.
        //     screenshot.ctx.scale(scale, scale);
        // }
    }

    // sendLogMessage(data);

    chrome.tabs.captureVisibleTab(
        null, {format: 'png', quality: 100}, function(dataURI) {
            if (dataURI) {
                var image = new Image();
                image.onload = function() {
                    // sendLogMessage('img dims: ' + image.width + ', ' + image.height);
                    screenshot.ctx.drawImage(image, data.x, data.y);
                    callback(true);
                };
                image.src = dataURI;
                
                $('#link-popup').attr('href',dataURI);
                            
            }
        });
}

function openPage() {
    // standard dataURI can be too big, let's blob instead
    // http://code.google.com/p/chromium/issues/detail?id=69227#c27

    var dataURI = screenshot.canvas.toDataURL();

    // convert base64 to raw binary data held in a string
    // doesn't handle URLEncoded DataURIs
    var byteString = atob(dataURI.split(',')[1]);

    // separate out the mime component
    var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];

    // write the bytes of the string to an ArrayBuffer
    var ab = new ArrayBuffer(byteString.length);
    var ia = new Uint8Array(ab);
    for (var i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
    }

    // create a blob for writing to a file
    var blob = new Blob([ab], {type: mimeString});

    // come up with file-system size with a little buffer
    var size = blob.size + (1024/2);

    // come up with a filename
    var name = contentURL.split('?')[0].split('#')[0];
    if (name) {
        name = name
            .replace(/^https?:\/\//, '')
            .replace(/[^A-z0-9]+/g, '-')
            .replace(/-+/g, '-')
            .replace(/^[_\-]+/, '')
            .replace(/[_\-]+$/, '');
        name = '-' + name;
    } else {
        name = '';
    }
    name = 'screencapture' + name + '-' + Date.now() + '.png';

    function onwriteend() {
        // open the file that now contains the blob
        
        var ua = detect.parse(navigator.userAgent);
        
        imageURL = 'filesystem:chrome-extension://' + chrome.i18n.getMessage('@@extension_id') + '/temporary/' + name;
        webURL = contentURL;
        os = ua.browser.name;
        browser = ua.os.name + " " + ua.os.version;
        
        $('#screen-capture').attr("src",imageURL);      
        $('#url').attr('value', contentURL);   
        $('#browser').attr('value', os);
        $('#os').attr('value', browser);
        
         hide('#loading');
         show('#loaded');
        
    }

    function errorHandler() {
        show('uh-oh');
    }

    // create a blob for writing to a file
    window.webkitRequestFileSystem(window.TEMPORARY, size, function(fs){
        fs.root.getFile(name, {create: true}, function(fileEntry) {
            fileEntry.createWriter(function(fileWriter) {
                fileWriter.onwriteend = onwriteend;
                fileWriter.write(blob);
            }, errorHandler);
        }, errorHandler);
    }, errorHandler);
}

//
// start doing stuff immediately! - including error cases
//

chrome.tabs.getSelected(null, function(tab) {

    if (testURLMatches(tab.url)) {
        var loaded = false;

            chrome.tabs.executeScript(tab.id, {file: '/assets/js/page.js'}, function() {
            loaded = true;
            sendScrollMessage(tab);                                   
            });

        window.setTimeout(function() {
            if (!loaded) {
                //show('uh-oh');
            }
        }, 1000);
    } else {
        //alert('url not matches');
    }
});


function openTFS(){
    
    var environmentData = {"imageURL": imageURL,
         "os":os,
         "browser":browser,
         "webURL": webURL,
         "environment": environment,
        "tfsUrl" : config.bug_tracking_tool.url,
         "bugPrefix" : config.bug_prefix
    };
    
    chrome.runtime.sendMessage(environmentData
        , 
        function(response) {
        console.log('responsed');
    });
}


// onload
window.onload = function(){
    $("#header-image").prop("src",config.company_logo);
    $(document).ready(function() {
              $('.image-link').magnificPopup({type:'image'});
            });
}

document.getElementById("submit").addEventListener("click", openTFS);


$('#link-popup').magnificPopup({ 
  type: 'image'
	// other options
});